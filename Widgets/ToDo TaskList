// Trilium Widget: Open Tasks Viewer
// Displays a list of unchecked tasks from notes with 'todo' or 'todolist' labels.
// Links to the source note and allows toggling task completion.

// Widget Template
const template = `
  <div id="my-widget" style="padding: 10px; border-top: 1px solid var(--main-border-color); contain: none;">
    <h2>Open Tasks</h2>
    <span id="todo-list" class="todo-list__label"></span>
  </div>
`;

// Main Widget Class
class MyWidget extends api.NoteContextAwareWidget {
  // Widget position and parent pane configuration
  get position() { return 100; } // Bottom of the center pane
  get parentWidget() { return 'center-pane'; }

  uncheckedTasks = []; // Store tasks to be rendered

  // Determines if the widget is enabled for the current note
  isEnabled() {
    return super.isEnabled() && 
           this.note.type === 'text' && 
           (this.note.hasLabel('todo') || this.note.hasLabel('todolist'));
  }

  // Renders the widget
  doRender() {
    this.uncheckedTasks = [];
    this.$widget = $(template); // Load the widget template
    this.$todolist = this.$widget.find('#todo-list'); // Task list container
    this.getContent(); // Fetch tasks
    this.cssBlock(`
      #my-widget {
        overflow: scroll;
        height: 25%;
        z-index: 1;
      }
    `);
    this.tasksRender(); // Render tasks
    return this.$widget;
  }

  // Render tasks into the widget
  tasksRender() {
    let currentNoteTitle = ''; // Track the current note to group tasks
    this.uncheckedTasks.forEach(task => {
      if (currentNoteTitle !== task.noteId) {
        // Add the note title if it's a new group
        this.$todolist.append(
          `<h3 class="task"><a href="/root/${task.noteId}" id="${task.noteId}" class="noteLinks">${task.noteTitle}</a></h3>`
        );
        currentNoteTitle = task.noteId;
      }
      // Add the task itself
      this.$todolist.append(`<div class="task">${task.displayTask()}</div>`);
    });
  }

  // Fetch content from notes and populate unchecked tasks
  async getContent() {
    this.uncheckedTasks = [];
    const searchStr = `note.ancestors.noteId='${this.noteId}' and (~template='Day template' or #todo)`;
    const childNotes = await api.searchForNotes(searchStr);

    for (let note of childNotes) {
      const { content } = await note.getBlob(); // Get the note's content as HTML
      if (content) {
        const taskRegex = /<label class="todo-list__label">\s*<input type="checkbox"[^>]*>\s*<span class="todo-list__label__description">([^<]+)<\/span>\s*<\/label>/g;
        let match;
        let counter = 0;

        // Extract tasks from the content
        while ((match = taskRegex.exec(content)) !== null) {
          if (match[1] !== "&nbsp;" && !match[0].includes("checked")) {
            const tempTask = new Task(note.noteId, note.title, counter, match[1].trim());
            this.uncheckedTasks.push(tempTask);
          }
          counter++;
        }
      }
    }
  }

  // Refresh the widget when a note is updated
  async refreshWithNote() {
    await this.getContent(); // Re-fetch tasks
    this.$todolist.empty(); // Clear current tasks
    this.tasksRender(); // Re-render tasks

    // Attach events for task links and checkboxes
    this.$widget.find(".noteLinks").on("click", function () {
      api.openTabWithNote($(this).attr("id"), true);
    });

    this.$widget.find("input:checkbox").on("click", async function () {
      const noteId = $(this).attr("data-noteId");
      const taskId = $(this).attr("data-taskId");
      const checked = $(this).prop("checked");
      await MyWidget.updateTask(noteId, taskId, checked);
    });
  }

  // Update task status in a note
  static async updateTask(noteId, taskIndex, checked) {
    const data = await api.runOnBackend(async (noteId) => {
      const note = api.searchForNote(`note.noteId="${noteId}"`);
      return note ? note.getContent() : null;
    }, [noteId]);

    if (data) {
      const $tmpnote = $(data);
      $tmpnote.find("input[type='checkbox']").eq(taskIndex).prop("checked", checked);

      const content = $tmpnote.map((index, elem) => $(elem).prop("outerHTML")).toArray();
      await api.runOnBackend((noteId, content) => {
        const note = api.getNote(noteId);
        if (note) note.setContent(content);
      }, [noteId, content]);
    }
  }
}

// Task Class to store individual task data
class Task {
  constructor(noteId, noteTitle, taskIndex, taskText) {
    this.noteId = noteId; // ID of the source note
    this.noteTitle = noteTitle; // Title of the source note
    this.taskIndex = taskIndex; // Task index within the note
    this.taskText = taskText; // Task text
  }

  // Render the task's HTML representation
  displayTask() {
    return `
      <span contenteditable="false">
        <input type="checkbox" tabindex="-1" data-noteId="${this.noteId}" data-taskId="${this.taskIndex}">
      </span>
      <span class="todo-list__label__description">${this.taskText}</span>
    `;
  }
}

module.exports = new MyWidget();
